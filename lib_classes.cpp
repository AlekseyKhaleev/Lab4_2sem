/**********************************************************************************************************************
* Данный модуль содержит определения методов собственных классов, определенных в "classes.h"
**********************************************************************************************************************/

/* Подключение модулей */
#include <string>
#include <iostream>
#include "lib_classes.h"

using namespace PC_const;
using namespace lib_classes;
/*********************************************************************************************************************/
/*                                            SyntaxException class                                                               */
/*********************************************************************************************************************/

SyntaxException::SyntaxException(const std::string &message, int type, int argc) : runtime_error{message} {
    _type=type;
    _argc=argc;
}

void SyntaxException::description(){
    /*****************************************************************************************************************
    * Цель: Вывести в STDOUT сообщение с описанием полученной ошибки аргументов и краткую справку.
    * Исходные данные:
     *  type - закрытая переменная класса SyntaxException
     *  argc - закрытая переменная класса SyntaxException
    * Результат: В поток вывода выведено сообщение об ошибке.
    * Вызываемые модули: <string>, "classes.h"
    * Описание алгоритма:
    * 1) Определяется массив string[], содержащий общую информацию о корректных аргументах
    * 2) Выводится сообщение, в котором:
     * type - тип ошибки
     * argc - количество полученных аргументов
     * what() - возвращенное описание ошибки
    * 3) В цикле по строчно выводится базовое сообщение
    * Дата: 15 / 05 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    *****************************************************************************************************************/
    std::string error_msg[] = {
            "Correct arguments for run this app:\n\n",
            "--help or -h : help mode\n",
            "-с [N] [file_name] : create spreadsheet mode\n",
            "-r [N] [file_name] : read spreadsheet mode\n\n",
            "N – the number of records;\n",
            "file_name – file name or full path to save/read the table;\n\n"
    };
    std::cout << "\nSyntax Exception Type " << _type << " : " << _argc - 1 << " arguments given.\n" << what() << "\n\n";
    for (auto &i: error_msg) {
        std::cout << i;
    }
}

/*********************************************************************************************************************/
/*                                            PC class                                                               */
/*********************************************************************************************************************/

void PC::set(int row_to_print){
    /*****************************************************************************************************************
    * Цель: Инициализация элементов структуры значениями, считанными из потока STDIN с перемещением
    * курсора во время ввода в соответствующие ячейки таблицы.
    * Исходные данные:
    *   row_to_print - строка таблицы, в которой должен осуществляться ввод
    * Результат: Элементы структуры инициализированы соответствующими значениями.
    * Вызываемые модули: <iostream>, "structs.h", "definitions.h"
    * Описание алгоритма:
    * 1) Переменная current_col, соответствующая позиции текущего столбца для ввода, инициализируется
    * начальным значением START_COL
    * 2) Для каждого элемента структуры:
    *   - курсор перемещается в очередную позицию (используются шаги сдвига курсора)
    *   - производится пользовательский ввод с клавиатуры очередного значения элемента структуры
    * Дата: 23 / 05 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    *****************************************************************************************************************/

    int current_col = START_COL;
    move_cursor(START_ROW + row_to_print * STEP_ROW, START_COL);
    for(auto & _attribute : _attributes){ // обход аттрибутов объекта через указатели
        std::cin >> *_attribute; // ввод
        move_cursor(START_ROW + row_to_print * STEP_ROW, current_col += STEP_COL); // перемещение курсора
    }
}
void PC::print(int row_to_print){
    /*****************************************************************************************************************
    * Цель: Вывод элементов структуры с перемещением курсора во время вывода в соответствующие ячейки таблицы.
    * Исходные данные:
    *   row_to_print - строка таблицы, в которой должен осуществляться вывод
    * Результат: Элементы структуры выведены в соответствующих ячейках таблицы.
    * Вызываемые модули: <iostream>
    * Описание алгоритма:
    * 1) Переменная current_col, соответствующая позиции текущего столбца для вывода, инициализируется
    * начальным значением START_COL
    * 2) Для каждого элемента структуры:
    *   - курсор перемещается в очередную позицию (используются шаги сдвига курсора)
    *   - производится вывод очередного значения элемента структуры
    * Дата: 23 / 05 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    *****************************************************************************************************************/

    int current_col = START_COL;
    move_cursor(START_ROW + row_to_print * STEP_ROW, START_COL);
    for(auto &_attribute:_attributes){ // обход аттрибутов объекта через указатели
        std::cout << *_attribute; // вывод
        move_cursor(START_ROW + row_to_print * STEP_ROW, current_col += STEP_COL); // перемещение курсора
    }
}
void PC::write(std::fstream &fd){
    /*****************************************************************************************************************
    * Цель: Запись атрибутов объекта в файл.
    * Исходные данные:
    *   fd - поток с файловым дескриптором fd
    * Результат: данные атрибутов объекта записаны в файл.
    * Вызываемые модули: <fstream>, <iostream>
    * Описание алгоритма:
    * Все объекты имеют пользовательский тип(класс) String. Для каждого атрибута:
    * 1) С помощью метода get_size() в переменную записывается размер массива символов, содержащихся в значении атрибута
    * 2) В файл записывается полученный размер
    * 3) В файл записывается сам массив, полученный с помощью метода get() и являющийся значением атрибута
    * Дата: 23 / 05 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    *****************************************************************************************************************/
    for(auto &_attribute:_attributes){ // обход атрибутов экземпляра класса с помощью указателей
        lib_strings::size_t attr_size = _attribute->get_size(); //узнаем размер
        fd.write((char *) &attr_size, sizeof(lib_strings::size_t)); // записываем размер в файл
        fd.write((char *) &*_attribute->get(), long(attr_size));  // записываем массив char* полученного размера,
        // соответствующий атрибуту в файл
    }
}
void PC::read(std::fstream &fd) {
    /*****************************************************************************************************************
    * Цель: Чтение из файла атрибутов объекта.
    * Исходные данные:
    *   fd - поток с файловым дескриптором fd
    * Результат: данные атрибутов объекта записаны в файл.
    * Вызываемые модули: <fstream>, <iostream>
    * Описание алгоритма:
    * Все объекты имеют пользовательский тип(класс) String. Для каждого атрибута:
    * 1) Объявляется переменная пользовательского типа для хранения размера массива char*, соответствующего атрибуту
    * 2) Из файла считывается размер массива char*, соответствующего атрибуту
    * 3) Объявляется переменная типа char* для чтения массива считанного размера из файла. Память выделяется в стеке
    * 4) С помощью объявленной переменной производится чтение из потока массива char*, соответствующего атрибуту
    * 5) С помощью перегруженного оператора присваивания для класса(типа) String производится инициализация атрибута
    * считанным значением (с выделением динамеческой памяти "под капотом", будет освобождена при уничтожении экземпляра
    * деструктором)
    * Дата: 23 / 05 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    *****************************************************************************************************************/
        for(auto &_attribute:_attributes){ // обход атрибутов экземпляра класса с помощью указателей
            lib_strings::size_t attr_size{0}; // объявляем переменную для считывания размера массива char* (атрибута)
            fd.read((char *) &attr_size, sizeof(lib_strings::size_t)); // считываем размер
            char content[attr_size]; // выделяем память в стеке под будущий момент
            fd.read((char *) &content, long(attr_size)); // считываем данные (элементы) массива char* атрибута
            *_attribute = content; // инициализируем атрибут
    }
}

/*********************************************************************************************************************/
